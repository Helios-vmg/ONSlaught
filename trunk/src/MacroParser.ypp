/*
* Copyright (c) 2008-2010, Helios (helios.vmg@gmail.com)
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright notice, 
*       this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * The name of the author may not be used to endorse or promote products
*       derived from this software without specific prior written permission. 
*     * Products derived from this software may not be called "ONSlaught" nor
*       may "ONSlaught" appear in their names without specific prior written
*       permission from the author. 
*
* THIS SOFTWARE IS PROVIDED BY HELIOS "AS IS" AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
* EVENT SHALL HELIOS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*/

%parse-param {cheap_input_stream &stream}
%parse-param {ParserState::ParserState &state}
%parse-param {NONS_Macro::file *&file}
%lex-param {cheap_input_stream &stream}
%lex-param {ParserState::ParserState &state}
%pure-parser
%defines
%debug
%file-prefix="MacroParser"
%name-prefix="macroParser_yy"
%code requires {
#include <string>
#include <sstream>
#include "Functions.h"
#include "MacroParser.h"
#undef ERROR
}
%code provides {
	int macroParser_yyparse(
		cheap_input_stream &stream,
		ParserState::ParserState &state,
		NONS_Macro::file *&file
	);
	int macroParser_yylex(
		YYSTYPE *yylval,
		cheap_input_stream &stream,
		ParserState::ParserState &state
	);
	inline void macroParser_yyerror(
		cheap_input_stream &,
		ParserState::ParserState &,
		NONS_Macro::file *file,
		char const *
	){}
	extern int macroParser_yydebug;
}
%union {
	std::wstring *str;
	NONS_Macro::file *file;
	std::vector<NONS_Macro::file_element *> *fe_list;
	NONS_Macro::file_element *file_element;
	NONS_Macro::text *text;
	NONS_Macro::push *push;
	NONS_Macro::call *call;
	std::vector<std::wstring> *params;
}
%token NEWLINE PUSH CALL PARAMS END_KEY COMMA_KEY POP ERROR END
%token <str> TEXT IDENTIFIER STRING
%type <str> parameter
%type <file> file;
%type <fe_list> newline_separated not_separated
%type <file_element> newline_separated_support not_separated_support
%type <text> text
%type <push> push
%type <call> call long_call long_call_header
%type <params> parameter_list long_parameter_list non_empty_parameter_list
%start begin
%destructor {
	delete $$;
} TEXT IDENTIFIER STRING file text push call long_call long_call_header parameter parameter_list long_parameter_list non_empty_parameter_list newline_separated not_separated newline_separated_support not_separated_support

%%

begin:
	file {
		file=$1;
		YYACCEPT;
	}|
	ERROR {
		YYABORT;
	};

file:
	newline_separated {
		$$=new NONS_Macro::file;
		$$->list=*$1;
		delete $1;
	}|
	not_separated {
		$$=new NONS_Macro::file;
		$$->list=*$1;
		delete $1;
	};

newline_separated_support:
	push {
		$$=$1;
	}|
	long_call {
		$$=$1;
	};

newline:
	NEWLINE |
	newline NEWLINE ;

newline_separated:
	newline_separated_support {
		$$=new std::vector<NONS_Macro::file_element *>;
		$$->push_back($1);
	}|
	newline_separated_support newline newline_separated {
		$$=$3;
		$$->insert($$->begin(),$1);
	}|
	not_separated newline newline_separated {
		$$=$1;
		append(*$$,*$3);
		delete $3;
	};

not_separated_support:
	text {
		$$=$1;
	}|
	call {
		$$=$1;
	};

not_separated:
	not_separated_support {
		$$=new std::vector<NONS_Macro::file_element *>;
		$$->push_back($1);
	}|
	not_separated not_separated_support {
		$$=$1;
		$$->push_back($2);
	}|
	newline_separated newline not_separated {
		$$=$1;
		append(*$$,*$3);
		delete $3;
	};

text:
	TEXT {
		$$=new NONS_Macro::text(*$1);
		delete $1;
	}|
	text TEXT {
		$$=$1;
		$$->str.push_back('\n');
		$$->str.append(*$2);
		delete $2;
	};

push:
	PUSH NEWLINE text END_KEY {
		$$=new NONS_Macro::push($3->to_string());
		delete $3;
	}|
	PUSH STRING NEWLINE text END_KEY {
		$$=new NONS_Macro::push($4->to_string(),*$2);
		delete $2;
		delete $4;
	};

call:
	CALL IDENTIFIER '(' parameter_list ')' {
		$$=new NONS_Macro::call(*$2,*$4);
		delete $2;
		delete $4;
		state=ParserState::AFTER_CALL;
	};

long_call_header:
	CALL IDENTIFIER '(' PARAMS ')' {
		$$=new NONS_Macro::call(*$2);
		state=ParserState::AFTER_LONG_CALL_HEADER;
		delete $2;
	};

long_call:
	long_call_header NEWLINE long_parameter_list END_KEY {
		append(($$=$1)->parameters,*$3);
		delete $3;
	};

parameter:
	STRING {
		$$=new std::wstring(*$1);
		delete $1;
	}|
	POP {
		$$=new std::wstring;
		$$->push_back(0);
	};

parameter_list:
	{
		$$=new std::vector<std::wstring>;
	}|
	non_empty_parameter_list {
		$$=$1;
	};

non_empty_parameter_list:
	parameter {
		$$=new std::vector<std::wstring>;
		$$->push_back(*$1);
		delete $1;
	}|
	non_empty_parameter_list ',' parameter {
		$$=$1;
		$$->push_back(*$3);
		delete $3;
	};

long_parameter_list:
	text {
		$$=new std::vector<std::wstring>;
		$$->push_back($1->to_string());
		delete $1;
	}|
	long_parameter_list COMMA_KEY NEWLINE text {
		$$=$1;
		$$->push_back($4->to_string());
		delete $4;
	};

%%

void putback(cheap_input_stream &stream,const std::wstring &s,ulong start_at=0,ulong length=std::wstring::npos){
	for (size_t a=((length==std::wstring::npos)?s.size():start_at+length);a>start_at;a--)
		stream.putback(s[a-1]);
}

bool read_identifier(std::wstring &dst,const std::wstring &src,ulong offset){
	if (!NONS_isid1char(src[offset]))
		return 0;
	ulong end=offset+1;
	for (;NONS_isidnchar(src[end]);end++);
	dst=src.substr(offset,end-offset);
	return 1;
}

bool read_identifier(std::wstring &dst,cheap_input_stream &stream){
	dst.clear();
	wchar_t c=stream.peek();
	if (stream.eof() || !NONS_isid1char(c))
		return 0;
	do
		dst.push_back(stream.get());
	while (NONS_isidnchar(stream.peek()) && !stream.eof());
	return 1;
}

int return_full_line(YYSTYPE *yylval,cheap_input_stream &stream,const std::wstring &s,ParserState::ParserState state){
	if (state==ParserState::TEXT)
		stream.putback('\n');
	yylval->str=new std::wstring(s);
	return TEXT;
}

int identify_keyword(const std::wstring &s){
	if (s==L"call")
		return CALL;
	if (s==L"push")
		return PUSH;
	if (s==L"end")
		return END_KEY;
	if (s==L"comma")
		return COMMA_KEY;
	if (s==L"pop")
		return POP;
	if (s==L"params")
		return PARAMS;
	return ERROR;
}

int macroParser_yylex(YYSTYPE *yylval,cheap_input_stream &stream,ParserState::ParserState &state){
	wchar_t c;
	c=stream.peek();
	switch (c){
		case '\n':
			if (state==ParserState::TEXT){
				stream.get();
				break;
			}else if (state==ParserState::TEXT_IN_BLOCK)
				break;
			else if (state==ParserState::AFTER_CALL){
				state=ParserState::TEXT;
				break;
			}
			else if (state==ParserState::NIL){
				state=ParserState::TEXT;
				yylval->str=new std::wstring;
				return TEXT;
			}
			else if (state==ParserState::AFTER_KEYWORD_LINE){
				state=ParserState::TEXT;
			}else if (state==ParserState::AFTER_PUSH || state==ParserState::AFTER_LONG_CALL_HEADER)
				state=ParserState::TEXT_IN_BLOCK;
			stream.get();
			return NEWLINE;
		case '(':
		case ')':
			return stream.get();
	}
	if (stream.eof())
		return 0;
	if (state==ParserState::TEXT || state==ParserState::TEXT_IN_BLOCK){
		std::wstring s=stream.getline();
		if (state==ParserState::TEXT){
			size_t semicolon_hash=s.find(L";#");
			if (semicolon_hash!=s.npos){
				if (semicolon_hash){
					yylval->str=new std::wstring(s.substr(0,semicolon_hash));
					stream.putback('\n');
					putback(stream,s,semicolon_hash);
					return TEXT;
				}
				std::wstring type;
				if (!read_identifier(type,s,2)){
					state=ParserState::TEXT;
					return return_full_line(yylval,stream,s,state);
				}
				int keyword=identify_keyword(type);
				if (keyword==ERROR){
					state=ParserState::TEXT;
					return return_full_line(yylval,stream,s,state);
				}
				state=(keyword==CALL)?ParserState::CALL:((keyword==PUSH)?ParserState::AFTER_PUSH:ParserState::NIL);
				stream.putback('\n');
				putback(stream,s,2+type.size());
				return keyword;
			}
		}else{
			if (s==L";#comma"){
				state=ParserState::AFTER_LONG_CALL_HEADER;
				stream.putback('\n');
				return COMMA_KEY;
			}
			if (s==L";#end"){
				state=ParserState::AFTER_KEYWORD_LINE;
				stream.putback('\n');
				return END_KEY;
			}
		}
		return return_full_line(yylval,stream,s,state);
	}
	while (!stream.eof() && ((c=stream.peek())==' ' || c=='\t'))
		stream.get();
	if (stream.eof())
		return 0;
	if (c=='\"'){
		wchar_t quote=stream.get();
		std::wstring s;
		while (stream.peek()!=quote && !stream.eof()){
			c=stream.get();
			if (c!='\\'){
				s.push_back(c);
			}else{
				switch (c=stream.get()){
					case '\\':
					case '\"':
						s.push_back(c);
						break;
					case 'n':
					case 'r':
					case 't':
						s.push_back('\n');
						break;
					case 'x':
						{
							std::wstring temp;
							for (ulong a=0;NONS_ishexa(stream.peek()) && a<4;a++)
								temp.push_back(stream.get());
							if (temp.size()<4)
								return ERROR;
							wchar_t a=0;
							for (size_t b=0;b<temp.size();b++)
								a=(a<<4)+HEX2DEC(temp[b]);
							s.push_back(a?a:32);
						}
						break;
					default:
						return ERROR;
				}
			}
		}
		if (stream.peek()==quote){
			yylval->str=new std::wstring(s);
			stream.get();
			return STRING;
		}
		return ERROR;
	}
	if (c=='#'){
		stream.get();
		std::wstring identifier;
		if (!read_identifier(identifier,stream))
			return ERROR;
		int keyword=identify_keyword(identifier);
		if (keyword==PARAMS)
			state=ParserState::TEXT_IN_BLOCK;
		return keyword;
	}
	if (NONS_isid1char(c)){
		std::wstring identifier;
		if (!read_identifier(identifier,stream))
			return ERROR;
		int key=identify_keyword(identifier);
		if (key!=ERROR)
			return key;
		yylval->str=new std::wstring(identifier);
		return IDENTIFIER;
	}
	return stream.get();
}
