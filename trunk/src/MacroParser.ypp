/*
* Copyright (c) 2008-2010, Helios (helios.vmg@gmail.com)
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright notice, 
*       this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * The name of the author may not be used to endorse or promote products
*       derived from this software without specific prior written permission. 
*     * Products derived from this software may not be called "ONSlaught" nor
*       may "ONSlaught" appear in their names without specific prior written
*       permission from the author. 
*
* THIS SOFTWARE IS PROVIDED BY HELIOS "AS IS" AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
* EVENT SHALL HELIOS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*/

%parse-param {cheap_input_stream &stream}
%parse-param {std::deque<wchar_t> &token_queue}
%parse-param {NONS_Macro::file *&file}
%lex-param {cheap_input_stream &stream}
%lex-param {std::deque<wchar_t> &token_queue}
%pure-parser
%defines
%debug
%expect 1
%file-prefix="MacroParser"
%name-prefix="macroParser_yy"
%code requires {
#include <string>
#include <sstream>
#include "Functions.h"
#include "MacroParser.h"
#undef ERROR
}
%code provides {
	int macroParser_yyparse(
		cheap_input_stream &stream,
		std::deque<wchar_t> &token_queue,
		NONS_Macro::file *&file
	);
	int macroParser_yylex(
		YYSTYPE *yylval,
		cheap_input_stream &stream,
		std::deque<wchar_t> &token_queue
	);
	inline void macroParser_yyerror(
		cheap_input_stream &,
		std::deque<wchar_t> &,
		NONS_Macro::file *file,
		char const *
	){}
	extern int macroParser_yydebug;
}
%union {
	std::wstring *str;
	ulong integer;
	NONS_Macro::file *file;
	NONS_Macro::file_element *file_element;
	NONS_Macro::text *text;
	NONS_Macro::call *call;
	std::vector<std::wstring> *params;
}
%token CALL DCALL PARAMS END_KEY COMMA_KEY ERROR
%token <integer> INTEGER
%token <str> TEXT IDENTIFIER STRING
%type <file> file;
%type <file_element> file_element
%type <text> text
%type <call> common_call_header call long_call
%type <params> parameter_list long_parameter_list non_empty_parameter_list
%start begin
%destructor {
	delete $$;
} TEXT IDENTIFIER STRING file file_element text common_call_header call long_call parameter_list long_parameter_list non_empty_parameter_list

%%

begin:
	file {
		file=$1;
		YYACCEPT;
	}|
	ERROR {
		YYABORT;
	};

file:
	{
		$$=new NONS_Macro::file;
	}|
	file file_element {
		$$=$1;
		$$->list.push_back($2);
	};

file_element:
	text {
		$$=$1;
	}|
	call {
		$$=$1;
	}|
	long_call {
		$$=$1;
	};

text:
	TEXT {
		$$=new NONS_Macro::text(*$1);
		delete $1;
	}|
	text TEXT {
		$$=$1;
		$$->str.append(*$2);
		delete $2;
	};

common_call_header:
	CALL IDENTIFIER {
		$$=new NONS_Macro::call(*$2);
		delete $2;
	}|
	CALL INTEGER IDENTIFIER {
		$$=new NONS_Macro::call(*$3,$2);
		delete $3;
	};

call:
	common_call_header '(' parameter_list ')' {
		$$=$1;
		$$->parameters=*$3;
		delete $3;
	};

long_call:
	common_call_header '(' PARAMS ')' long_parameter_list END_KEY {
		append(($$=$1)->parameters,*$5);
		delete $5;
	};

parameter_list:
	{
		$$=new std::vector<std::wstring>;
	}|
	non_empty_parameter_list {
		$$=$1;
	};

non_empty_parameter_list:
	STRING {
		$$=new std::vector<std::wstring>;
		$$->push_back(*$1);
		delete $1;
	}|
	non_empty_parameter_list ',' STRING {
		$$=$1;
		$$->push_back(*$3);
		delete $3;
	};

long_parameter_list:
	text {
		$$=new std::vector<std::wstring>;
		$$->push_back($1->to_string());
		delete $1;
	}|
	long_parameter_list COMMA_KEY text {
		$$=$1;
		$$->push_back($3->to_string());
		delete $3;
	};

%%

int identify_keyword(const std::wstring &s){
	if (s==L"call")
		return CALL;
	if (s==L"comma")
		return COMMA_KEY;
	if (s==L"params")
		return PARAMS;
	if (s==L"end")
		return END_KEY;
	return ERROR;
}

int macroParser_yylex(YYSTYPE *yylval,cheap_input_stream &stream,std::deque<wchar_t> &second_queue){
	while (1){
		while (second_queue.size()){
			wchar_t c=second_queue.front();
			if (iswhitespace(c)){
				second_queue.pop_front();
				continue;
			}
			if (c=='#'){
				second_queue.pop_front();
				std::wstring keyword;
				while (second_queue.size() && NONS_isidnchar(second_queue.front())){
					keyword.push_back(second_queue.front());
					second_queue.pop_front();
				}
				yylval->str=new std::wstring(keyword);
				return identify_keyword(keyword);
			}
			if (NONS_isid1char(c)){
				std::wstring identifier;
				identifier.push_back(c);
				second_queue.pop_front();
				while (second_queue.size() && NONS_isidnchar(second_queue.front())){
					identifier.push_back(second_queue.front());
					second_queue.pop_front();
				}
				yylval->str=new std::wstring(identifier);
				return IDENTIFIER;
			}
			if (NONS_isdigit(c)){
				std::wstring value;
				value.push_back(c);
				second_queue.pop_front();
				while (second_queue.size() && NONS_isdigit(second_queue.front())){
					value.push_back(second_queue.front());
					second_queue.pop_front();
				}
				yylval->integer=atoi(value);
				return INTEGER;
			}
			if (c=='\"'){
				wchar_t quote=c;
				second_queue.pop_front();
				std::wstring s;
				while (second_queue.size() && second_queue.front()!=quote){
					wchar_t c=second_queue.front();
					second_queue.pop_front();
					if (c!='\\')
						s.push_back(c);
					else if (second_queue.empty())
						return ERROR;
					else{
						c=second_queue.front();
						second_queue.pop_front();
						switch (c){
							case '\\':
							case '\"':
								s.push_back(c);
								break;
							case 'n':
							case 'r':
								s.push_back('\n');
								break;
							case 't':
								s.push_back('\t');
								break;
							case 'x':
								{
									if (second_queue.size()<4)
										return ERROR;
									std::wstring temp;
									for (ulong a=0;NONS_ishexa(second_queue.front()) && a<4;a++){
										temp.push_back(second_queue.front());
										second_queue.pop_front();
									}
									if (temp.size()<4)
										return ERROR;
									wchar_t a=0;
									for (size_t b=0;b<temp.size();b++)
										a=(a<<4)+HEX2DEC(temp[b]);
									s.push_back(a?a:32);
								}
						}
					}
				}
				if (!second_queue.size() || second_queue.front()!=quote)
					return ERROR;
				yylval->str=new std::wstring(s);
				second_queue.pop_front();
				return STRING;
			}
			second_queue.pop_front();
			return c;
		}
		std::wstring line;
		if (stream.eof())
			return 0;
		line=stream.getline();
		if (!firstchars(line,0,L";#")){
			yylval->str=new std::wstring(line);
			yylval->str->push_back('\n');
			return TEXT;
		}
		append(second_queue,line,1);
	}
}
